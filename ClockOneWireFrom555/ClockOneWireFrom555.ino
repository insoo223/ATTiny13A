/*  ClockOneWire2by8cm.ino
Target MCU: ATTiny13

Ref: Simple internal clock demo: by Joseph Unik aka Relic1974
    Uses analog PWM output of 490Hz with a 50% duty cycle to
    keep very accurate time ;).  Connect an LED to pin 13 to
    watch seconds blink.  Connect a jumper from Analog pin 0
    to Digital Pin 2 (interrupt 0). Minutes output to serial
    monitor.  http://www.planetxresearch.com 'Arduino' logo
    for more projects and tricks...
   
   
    (Feel free to use this code to expand into a fully-functional
    clock or other project under Creative Commons ;)
*/

#include <EEPROM.h>
//#include "pitches.h"
// notes in the melody:
//int melody[] = {NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3,0, NOTE_B3, NOTE_C4};

// note durations: 4 = quarter note, 8 = eighth note, etc.:
//int noteDurations[] = {4, 8, 8, 4,4,4,4,4 };

#define menuButton A3
#define tempSens A2
#define lightSens A1
#define menuSelCompleteINTERVAL  1000
#define hourAdjustCompleteINTERVAL 3000
#define oneHourMS (60L*60L*1000L)
//#define speakerPin 13

//eePtr at EEPROM address 0 indicates the address of the last stored hour
int eePtr=0;
int addrHour=1;
int addrMin=2;
byte storedHour, storedMin;
//wrtie count to EEPROM
byte eeWriteCnt=0;
byte currWrittenMinute=0, prevWrittenMinute=0;

int menuCnt=0;
unsigned long prevMSmenu=0, currMSmenu=0, lapseMenu=0;  

unsigned long prevlapOneHour=0;
unsigned long lapOneHourCnt=0;
unsigned long lapTenHourCnt=0;

int clockInt = 0;            // digital pin 2 is now interrupt 0
int masterClock = 0;         // counts rising edge clock signals

int seconds = 00;
int minutes = 25;
int hours = 15;  

// the first digital pin connected to 7-seg LED
int startPin = 3;  
// the last digital pin connected to 7-seg LED
int endPin = 13;

// 50% duty PWM pin of "pwmClock" is very accurate pulse generated by Arduino UNO
int pwmClock = 9;

//D8 will be high to light up DP
int DP = 8;

boolean setupMode=false, setupModeMinutes=false;

//Arduino pin 12,11,10,8,  6,5,4,3
int SevenSeg[14] = {
		0b11101110, //0
		0b00101000, //1
		0b11001101, //2
		0b01101101, //3
		0b00101011, //4
		0b01100111, //5
		0b11100011, //6
		0b00101100, //7
		0b11101111, //8
		0b00101111, //9
                0b00000000, //10 Blank
                0b11111111, //11 All
		0b11000011, //12 t 
		0b11000010, //13 L
                
	};//SevenSeg[10]

//function prototypes
void clockCounter(void);
void disp7seg(int);
void disp7seg_Sec(int);
int showDelayMS(unsigned long);
void show2DigitOnOne7Seg(int, int, int);
void show3DigitOnOne7Seg(int, int, int);
void calcHMS(void);
void countButton(int);
void showTime();
void chkButton(void);
void setHours(void);
void setMinutes(void);
void showEEPROM(void);
void showSec(void);
void alarmMinutes(unsigned long);
void playSpeaker(void);
void showTemp(void);
void showLightSensor(void);

//********************************************************
void setup()
{
  int i; 
  //attachInterrupt(clockInt, clockCounter, RISING);
      //  clockInt is our interrupt, clockCounter function is called when
      //  invoked on a RISING clock edge
  analogReference(DEFAULT);

  for (i=startPin; i<=endPin; i++)
    pinMode(i, OUTPUT);
  menuCnt = 4; // Display current time
  //menuCnt = 7; // test a specific menu function
  
  //init eePtr, when running this Arduino for the 1st time
  //EEPROM.write(eePtr, 1); showDelayMS(100);

  addrHour = EEPROM.read(eePtr)-2;
  //addrHour = 1;
  addrMin = addrHour+1;
  
  storedHour = EEPROM.read(addrHour);
  //Serial.print("EEPROM.read(addrHour): ");
  //Serial.println(storedHour);

  storedMin = EEPROM.read(addrMin);
  //Serial.print("EEPROM.read(addrMin): ");
  //Serial.println(storedMin);

  hours = storedHour;
  minutes = storedMin;

  analogWrite(pwmClock, 127);   // this starts our PWM 'clock' with a 50% duty cycle
}//setup

int toggle=0;
//********************************************************
void loop()
{
  //check menu button
  chkButton();
  
  //calculate hours, minutes, and seconds to display
  calcHMS();     
  
  // Experiments show the time ticks of my Arduino Pro Mini 16Mhz
  //   goes faster by rate of 188ms/min or 11.30769 seconds/hour
  adjTime();
}//loop

//********************************************************
void clockCounter()      // called by interrupt
{
  masterClock ++;        // with each clock rise add 1 to masterclock count
  //if(masterClock == 489) // 490Hz reached     
  if(masterClock == 1) // 1Hz reached     
  {                         
    seconds ++;          // after one 490Hz cycle add 1 second ;)
    masterClock = 0;     // Reset after 1 second is reached
    //tone(13, 100, 500);  // using tone to pulse LED without showDelayMS call ;)
   }
}//clockCounter

//********************************************************
void disp7seg(int num)
{
    //PORTD: 7 6 5 4  3 2 1 0
    //    bit3 2 1 0
    //pin    6 5 4 3 
    //PORTD = (SevenSeg[num]<<3) & 0x78;
    
    //PORTB: x x 13 12  11 10 9 8
    //    bit7  6  5 4
    //pin   12 11 10 8 
    digitalWrite(8, ((SevenSeg[num]>>4) & 0x01));
    digitalWrite(10, ((SevenSeg[num]>>5) & 0x01));
    digitalWrite(11, ((SevenSeg[num]>>6) & 0x01));
    digitalWrite(12, ((SevenSeg[num]>>7) & 0x01));
}//disp7seg

//********************************************************
void disp7seg_Sec(int state)
{
  //digitalWrite(onesDigit, state);
}//disp7seg

//********************************************************
int showDelayMS(unsigned long ms)
{
  unsigned long prevMS, currMS, lapMS;
  unsigned long finMS;
  
  finMS = ms;

  currMS = millis();
  prevMS = currMS;
  lapMS = currMS - prevMS;
  
  while (lapMS < finMS)
  {
    currMS = millis();
    lapMS = currMS - prevMS;
  }//while
  return 0;
}//showDelayMS

//********************************************************
void show2DigitOnOne7Seg(int num, int deciPoint, int duration)
{    
  int i;
  for (i=0; i<duration; i++)
  {
    //display tens by modulating the number
    disp7seg(num / 10);
    //Light up DP or not
    //DP represents hours in this application
    digitalWrite(DP, deciPoint);
    //persist the display time for 500ms
    showDelayMS(500);

    //display ones by modulating the number
    disp7seg(num % 10);
    digitalWrite(DP, deciPoint);
    //persist the display time for 500ms
    showDelayMS(500);
    
    digitalWrite(DP, LOW);
  }//for
}//void show2DigitOnOne7Seg

//********************************************************
void show3DigitOnOne7Seg(int num, int deciPoint, int duration)
{    
  int i;
  for (i=0; i<duration; i++)
  {
    //display hundreds by modulating the number
    disp7seg(num / 100);
    //Light up DP or not
    //DP represents hours in this application
    digitalWrite(DP, deciPoint);
    //persist the display time for 500ms
    showDelayMS(500);

    //display tens by modulating the number
    disp7seg((num/10) % 10);
    //Light up DP or not
    //DP represents hours in this application
    digitalWrite(DP, !deciPoint);
    //persist the display time for 500ms
    showDelayMS(500);

    //display ones by modulating the number
    disp7seg(num % 10);
    digitalWrite(DP, deciPoint);
    //persist the display time for 500ms
    showDelayMS(500);
    
    digitalWrite(DP, LOW);
  }//for
}//void show3DigitOnOne7Seg


//********************************************************
void calcHMS()   
{
  //calculate hours, minutes, and seconds
  //displaying routine can take over 1 second, 
  //so that add check condition (seconds > 60). 
  if(seconds >= 60)  // NOW GETTING IN TO REAL TIME KEEPING
  {
    minutes ++;          // increment minutes by 1
    if (seconds == 60)
      seconds = 0;         // reset the seconds variable
    else
      seconds = seconds % 60;         // reset the seconds variable    
  }
  
  if(minutes >= 60)      // NOW GETTING IN TO REAL TIME KEEPING
  {
    hours ++;          // increment minutes by 1
    if (minutes == 60)
      minutes = 0;         // reset the minutes variable
    else
      minutes = minutes % 60;         // reset the minutes variable    
  }

  if(hours == 24)      // NOW GETTING IN TO REAL TIME KEEPING
  {
    hours = 0;         // reset the hours variable
  }
}//void calcHMS()

//********************************************************
void countButton(int button)
{
  //if pressed, grounded
  if (analogRead(button) < 200)
  {
    showDelayMS(200); // for debounce
    if (button == menuButton)
      menuCnt++;
    prevMSmenu = millis();
  }//if (analogRead(button) < 200)
}//countButton

//********************************************************
void showTime()
{
  unsigned long currTime, prevTime;
  
  //show hours for 1sec
  show2DigitOnOne7Seg(hours, HIGH,1);    

  //show minutes for 1sec
  show2DigitOnOne7Seg(minutes, LOW,1);

  //give a one second delay to get button input if user want
  //show blank for 0.2sec 
  currTime = millis();
  prevTime = currTime;
  while (currTime - prevTime < 200)
  {
    currTime = millis();
    disp7seg(10); //blank    
  }//while
  
  // write EEPROM delay 0.4sec
  if ( ((minutes != prevWrittenMinute) && (minutes % 30 == 0)) || (eeWriteCnt ==0) )
  {
    prevWrittenMinute = minutes;
    eeWriteCnt++;
    addrHour = EEPROM.read(eePtr); showDelayMS(100);
//    Serial.print("WRITE EEPROM addrHour: "); Serial.print(addrHour);
    
    EEPROM.write(addrHour, hours); showDelayMS(100);
//    Serial.print(", hours: "); Serial.println(hours);

//    Serial.print("EEPROM addrHour+1: "); Serial.print(addrHour+1);
    EEPROM.write(addrHour+1, minutes); showDelayMS(100);
//    Serial.print(", minutes: "); Serial.println(minutes);

    if (addrHour <= 251)
    {
      EEPROM.write(eePtr, addrHour+ 2); 
      showDelayMS(100);
    }
    else
    {
      addrHour=1;
      EEPROM.write(eePtr, addrHour); 
      showDelayMS(100);
    }
    
  }//if (minutes % 30 == 0)

}//void showTime()

//********************************************************
void chkButton()
{
  countButton(menuButton);

  currMSmenu = millis();
  lapseMenu = currMSmenu - prevMSmenu;

  if (lapseMenu > menuSelCompleteINTERVAL)
  {
    switch (menuCnt)
    {
      //set time using Serial monitor
      case 1:
      {
        //After press menu button once,
        //and at the serial monitor input space,
        //put current time like 203214 and enter
        //which means 20h 32m 14s
        //setTimeViaSerial();
        menuCnt = 4;
        break;
      }
      //set hours by menu button
      case 2:
      {
        setHours();
        setMinutes();
        menuCnt = 4;
        break;
      }
      //set minutes by menu button
      case 3:
      {
        showSec();
        menuCnt = 4;
        break;
      }
      //Show current time (hour and min for 1sec each)
      case 4:
      {
        showTime();
        menuCnt = 4;
        break;
      }
      //Alarm 3 min
      case 5:
      {
        alarmMinutes(3);
        playSpeaker();
        menuCnt = 4;
        break;
      }
      //Alarm 5 min
      case 6:
      {
        alarmMinutes(5);
        playSpeaker();
        menuCnt = 4;
        break;
      }
      case 7:
      {
        //Alarm 10 min
        //alarmMinutes(10);
        //playSpeaker();
        
        //show temperature
        showTemp();
        menuCnt = 4;
        break;
      }
      case 8:
      {
        //Show seconds for 10 sec
        //showSec();
        
        //Show Light intensity
        showLightSensor();
        menuCnt = 4;
        break;
      }
      
      //set menuCnt 0 to enable time set function
      case 9:
      {
        menuCnt = 0;
        //show2DigitOnOne7Seg(0, LOW, 1000);
        disp7seg(10); //blank
        break;
      }
      default:
      {
        //show2Digit7Seg(88, HIGH, 1000);
        //showSec();
        menuCnt = 0;
      }
    }//switch
    prevMSmenu = millis();
  }//if (lapse > menuSelCompleteINTERVAL)    
}//chkButton()

//********************************************************
void setHours()
{
  unsigned int cMS=0, pMS=0, lapse=0;
  unsigned long currTime, prevTime;
  boolean done;
  
  done=false;
//  Serial.println("setHours()");

  cMS = millis();
  pMS = cMS;
  lapse = cMS - pMS;
  
  while (!done)
  {
    show2DigitOnOne7Seg(hours, HIGH, 1);
    //Serial.println(analogRead(menuButton));
    //if pressed, grounded
    if (analogRead(menuButton) < 200)
    {
      showDelayMS(200); // for debounce
      hours++;
      if (hours >= 24)
        hours=0;
      pMS = millis();
      /*
      Serial.print("hours: "); Serial.println(hours);
      Serial.print("Time: "); 
      Serial.print(hours); Serial.print(":");
      Serial.print(minutes); Serial.print(":");
      Serial.print(seconds); 
      */
    }//if (analogRead(button) < 200)

    cMS = millis();
    lapse = cMS - pMS;
    //Serial.print("lapse: "); Serial.println((int)lapse/1000);
    if (lapse > hourAdjustCompleteINTERVAL)
    {
      done = true;
      //Serial.print("menuCnt: "); Serial.println(menuCnt);
      //showDelayMS(1000);
      menuCnt = 0;
      //break;
//      Serial.println("Done - setHours()");
    }
  }//while (!done)
}//setHours

//********************************************************
void setMinutes()
{
  unsigned int cMS=0, pMS=0, lapse=0;
  boolean done;
  
  done=false;
//  Serial.println("setMinutes()");
  //show2Digit7Seg(hours, HIGH, 10);
  cMS = millis();
  pMS = cMS;
  lapse = cMS - pMS;
  
  while (!done)
  {
    show2DigitOnOne7Seg(minutes, LOW, 1);
    //Serial.println("while (!done)");
    //if pressed, grounded
    if (analogRead(menuButton) < 200)
    {
      showDelayMS(200); // for debounce
      minutes++;
      if (minutes >= 60)
        minutes=0;
      pMS = millis();

/*
      Serial.print("hours: "); Serial.println(hours);
      Serial.print("Time: "); 
      Serial.print(hours); Serial.print(":");
      Serial.print(minutes); Serial.print(":");
      Serial.print(seconds); 
*/      
    }//if (analogRead(button) < 200)

    cMS = millis();
    lapse = cMS - pMS;
    //Serial.print("lapse: "); Serial.println((int)lapse/1000);
    if (lapse > hourAdjustCompleteINTERVAL)
    {
      done = true;
      //Serial.print("menuCnt: "); Serial.println(menuCnt);
      //showDelayMS(1000);
      menuCnt = 0;
      //break;
//      Serial.println("Done - setMinutes()");
    }
  }//while (!done)
  seconds = 0;
}//setMinutes


void showEEPROM()
{
  addrHour = EEPROM.read(eePtr);
  addrMin = addrHour+1;
//  Serial.print("EEPROM.read(eePtr): ");
//  Serial.println(addrHour);
  
  storedHour = EEPROM.read(addrHour);
//  Serial.print("EEPROM.read(addrHour): ");
//  Serial.println(storedHour);

  storedMin = EEPROM.read(addrMin);
//  Serial.print("EEPROM.read(addrMin): ");
//  Serial.println(storedMin);
}//showEEPROM

//********************************************************
void showSec()
{
  unsigned long currTime, prevTime;
  

 //show seconds for 1sec
  currTime = millis();
  prevTime = currTime;
  while (currTime - prevTime < 10000)
  {
    currTime = millis();
    calcHMS();
    show2DigitOnOne7Seg(seconds, LOW,1);    
  }//while

}//void showSec()

//********************************************************
void alarmMinutes(unsigned long alarmDuration)
{
  unsigned long currTime, prevTime, alarmMS, tick=0, lapTime=0;
  int prevResidualMin=0, currResidualMin=0;
  
  alarmMS = alarmDuration * 60L * 1000L;
  //alarmMS = 10000L;
  
 //show alarm count 
  currTime = millis();
  prevTime = currTime;
  while (currTime - prevTime < alarmMS)
  {
    currTime = millis();
    calcHMS();
    if (currTime - lapTime > 1000)
    {
      lapTime = millis();
      tick++;     
    }
    //show2DigitOnOne7Seg(alarmDuration - int(tick/60), LOW,1);  
    currResidualMin = alarmDuration - int(tick/60);
    if (currResidualMin != prevResidualMin)
    {
      disp7seg(currResidualMin);  
      prevResidualMin = currResidualMin;
    }
  }//while
  
}//alarmMinutes

//********************************************************
void playSpeaker()
{
  /*
  // iterate over the notes of the melody:
  for (int thisNote = 0; thisNote < 8; thisNote++) {

    // to calculate the note duration, take one second
    // divided by the note type.
    //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
    int noteDuration = 1000/noteDurations[thisNote];
    tone(speakerPin, melody[thisNote],noteDuration);

    // to distinguish the notes, set a minimum time between them.
    // the note's duration + 30% seems to work well:
    int pauseBetweenNotes = noteDuration * 1.30;
    delay(pauseBetweenNotes);
    // stop the tone playing:
    noTone(speakerPin);
  }
  */
} //playSpeaker

//********************************************************
// Experiments show the time ticks of my Arduino Pro Mini 16Mhz
//   goes faster by rate of 188ms/min or 11.30769 seconds/hour
//   
void adjTime()
{
  unsigned long sysLapTime=0;
  //show alarm count 
  sysLapTime = millis();
  if (sysLapTime - prevlapOneHour > oneHourMS)
  {
    prevlapOneHour = millis();
    seconds = seconds - 11;
    lapOneHourCnt++;
  }//if

  if (lapOneHourCnt == 10)
  {
    prevlapOneHour = millis();
    seconds = seconds - 3;
    lapTenHourCnt++;
    lapOneHourCnt = 0;
  }//if

  if (lapTenHourCnt == 100)
  {
    prevlapOneHour = millis();
    seconds = seconds - 7;
    lapTenHourCnt=0;
  }//if
}//adjTime
//********************************************************
int tempCnt=0;
void showTemp()
{
  /*
  int raw; 
  float mV, K, celsius;  
  unsigned long currTime=0, prevTime=0;

  while (tempCnt < 5)
  {
    tempCnt++;
    raw = analogRead(A2);
    mV = ((float)raw/1023.0) * 5000.0;
    K = mV/10;
    celsius= K - 273.15;
    Serial.print("ADC: ");
    Serial.print(raw);
    Serial.print(", mV: ");
    Serial.print(mV);
    Serial.print(", Celcius: ");
    Serial.println(int(celsius));
  
    //display "t" as temperature
    disp7seg(12);  
    showDelayMS(500);
    //show temperature for 1sec
    show2DigitOnOne7Seg(int(celsius), HIGH,1);
  
    //give some delay to get button input if user want
    currTime = millis();
    prevTime = currTime;
    while (currTime - prevTime < 500)
    {
      currTime = millis();
      disp7seg(10); //blank    
    }//while(currTime - prevTime < 500)
  }//while (tempCnt<5)
  tempCnt = 0;
*/  
}//showTemp()
//********************************************************
int lightCnt=0;
void showLightSensor()
{
  /*
  int lightIntensity;
  unsigned long currTime=0, prevTime=0;
  
  while (lightCnt < 5)
  {
    lightCnt++;
    lightIntensity = analogRead(lightSens);
    Serial.print("Light Sensor LM335: ");
    Serial.println(lightIntensity);
  
    //display "L" as Light
    disp7seg(13);  
    showDelayMS(500);
    //show temperature for 1sec
    //show2DigitOnOne7Seg(lightIntensity, HIGH,1);
    show3DigitOnOne7Seg(lightIntensity, HIGH,1);
  
    //give some delay to get button input if user want
    currTime = millis();
    prevTime = currTime;
    while (currTime - prevTime < 500)
    {
      currTime = millis();
      disp7seg(10); //blank    
    }//while (currTime - prevTime < 500)
  }//while (lightCnt < 5)
  
   lightCnt=0;
*/
}//showLightSensor()  
//********************************************************

